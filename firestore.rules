/**
 * Core Philosophy: This ruleset implements a strict, user-centric security model. All data is considered private and is
 * nested within a user-specific data tree, ensuring that users can only access and modify their own information. The
 * default security posture is deny-all, with permissions explicitly granted.
 *
 * Data Structure: The entire data model is hierarchical, starting with a top-level `/users` collection. Each user's
 * profile, custom states, and todos are stored as a document and subcollections under `/users/{userId}`, where `{userId}`
 * is the user's Firebase Authentication UID. This structure provides strong data isolation between users.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only ever interact with documents within their own `/users/{userId}` path. Cross-user
 *   data access is strictly forbidden.
 * - No User Listing: The top-level `/users` collection cannot be listed to prevent enumeration of all application users.
 * - Ownership Integrity: For all created documents, the rules enforce that an internal `userId` field matches the `userId`
 *   from the document path, ensuring data consistency and clear ownership. This ownership link is immutable once set.
 *
 * Denormalization for Authorization: This ruleset leverages a path-based security model, which is the most performant
 * approach. The `{userId}` wildcard in paths like `/users/{userId}/todos/{todoId}` is used directly to authorize requests,
 * eliminating the need for slow and costly `get()` calls to other documents. The `userId` field is denormalized onto
 * `State` and `Todo` documents primarily to enforce data consistency and integrity, not for authorization checks on
 * individual documents.
 *
 * Structural Segregation: The data model naturally segregates each user's data into its own document tree, which is an
 * ideal pattern for security and query performance. There is no mixing of public and private data within any single collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------------

    /**
     * Verifies that the request is coming from an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations, ensuring the user is the owner
     * AND the document they are trying to modify actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a new UserProfile document contains an 'id' field that
     * matches the document's ID ({userId}), ensuring relational integrity on creation.
     */
    function hasCorrectUserProfileData(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the UserProfile's 'id' field remains unchanged,
     * preventing the ownership link from being broken.
     */
    function isUserProfileOwnerImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that a new State document contains a 'userId' field that
     * matches the {userId} from the path, ensuring relational integrity on creation.
     */
    function hasCorrectStateData(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On update, ensures the State's 'userId' field remains unchanged,
     * preventing the ownership link from being broken.
     */
    function isStateOwnerImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Validates that a new Todo document contains a 'userId' field that
     * matches the {userId} from the path, ensuring relational integrity on creation.
     */
    function hasCorrectTodoData(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On update, ensures the Todo's 'userId' field remains unchanged,
     * preventing the ownership link from being broken.
     */
    function isTodoOwnerImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // --------------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------------

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow (get, update, delete) A signed-in user accessing their own profile document.
     * @allow (create) A new user creating their own profile document.
     * @deny (list) Any user trying to list all user profiles.
     * @deny (get) A user trying to read another user's profile.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasCorrectUserProfileData(userId);
      allow update: if isExistingOwner(userId) && isUserProfileOwnerImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private collection of custom states.
     * @path /users/{userId}/states/{stateId}
     * @allow (get, list, create, update, delete) A signed-in user managing states within their own profile.
     * @deny (get) A user trying to read states from another user's profile.
     * @deny (list) A user trying to list states from another user's profile.
     * @principle Enforces data ownership within a user-specific subcollection.
     */
    match /users/{userId}/states/{stateId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasCorrectStateData(userId);
      allow update: if isExistingOwner(userId) && isStateOwnerImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private collection of todo items.
     * @path /users/{userId}/todos/{todoId}
     * @allow (get, list, create, update, delete) A signed-in user managing todos within their own profile.
     * @deny (get) A user trying to read todos from another user's profile.
     * @deny (list) A user trying to list todos from another user's profile.
     * @principle Enforces data ownership within a user-specific subcollection.
     */
    match /users/{userId}/todos/{todoId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasCorrectTodoData(userId);
      allow update: if isExistingOwner(userId) && isTodoOwnerImmutable();
      allow delete: if isExistingOwner(userId);
    }
  }
}